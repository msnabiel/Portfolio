"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/thumbhash@0.1.1";
exports.ids = ["vendor-chunks/thumbhash@0.1.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/thumbhash@0.1.1/node_modules/thumbhash/thumbhash.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/thumbhash@0.1.1/node_modules/thumbhash/thumbhash.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rgbaToDataURL: () => (/* binding */ rgbaToDataURL),\n/* harmony export */   rgbaToThumbHash: () => (/* binding */ rgbaToThumbHash),\n/* harmony export */   thumbHashToApproximateAspectRatio: () => (/* binding */ thumbHashToApproximateAspectRatio),\n/* harmony export */   thumbHashToAverageRGBA: () => (/* binding */ thumbHashToAverageRGBA),\n/* harmony export */   thumbHashToDataURL: () => (/* binding */ thumbHashToDataURL),\n/* harmony export */   thumbHashToRGBA: () => (/* binding */ thumbHashToRGBA)\n/* harmony export */ });\n/**\n * Encodes an RGBA image to a ThumbHash. RGB should not be premultiplied by A.\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns The ThumbHash as a Uint8Array.\n */\nfunction rgbaToThumbHash(w, h, rgba) {\n  // Encoding an image larger than 100x100 is slow with no benefit\n  if (w > 100 || h > 100) throw new Error(`${w}x${h} doesn't fit in 100x100`)\n  let { PI, round, max, cos, abs } = Math\n\n  // Determine the average color\n  let avg_r = 0, avg_g = 0, avg_b = 0, avg_a = 0\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255\n    avg_r += alpha / 255 * rgba[j]\n    avg_g += alpha / 255 * rgba[j + 1]\n    avg_b += alpha / 255 * rgba[j + 2]\n    avg_a += alpha\n  }\n  if (avg_a) {\n    avg_r /= avg_a\n    avg_g /= avg_a\n    avg_b /= avg_a\n  }\n\n  let hasAlpha = avg_a < w * h\n  let l_limit = hasAlpha ? 5 : 7 // Use fewer luminance bits if there's alpha\n  let lx = max(1, round(l_limit * w / max(w, h)))\n  let ly = max(1, round(l_limit * h / max(w, h)))\n  let l = [] // luminance\n  let p = [] // yellow - blue\n  let q = [] // red - green\n  let a = [] // alpha\n\n  // Convert the image from RGBA to LPQA (composite atop the average color)\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255\n    let r = avg_r * (1 - alpha) + alpha / 255 * rgba[j]\n    let g = avg_g * (1 - alpha) + alpha / 255 * rgba[j + 1]\n    let b = avg_b * (1 - alpha) + alpha / 255 * rgba[j + 2]\n    l[i] = (r + g + b) / 3\n    p[i] = (r + g) / 2 - b\n    q[i] = r - g\n    a[i] = alpha\n  }\n\n  // Encode using the DCT into DC (constant) and normalized AC (varying) terms\n  let encodeChannel = (channel, nx, ny) => {\n    let dc = 0, ac = [], scale = 0, fx = []\n    for (let cy = 0; cy < ny; cy++) {\n      for (let cx = 0; cx * ny < nx * (ny - cy); cx++) {\n        let f = 0\n        for (let x = 0; x < w; x++)\n          fx[x] = cos(PI / w * cx * (x + 0.5))\n        for (let y = 0; y < h; y++)\n          for (let x = 0, fy = cos(PI / h * cy * (y + 0.5)); x < w; x++)\n            f += channel[x + y * w] * fx[x] * fy\n        f /= w * h\n        if (cx || cy) {\n          ac.push(f)\n          scale = max(scale, abs(f))\n        } else {\n          dc = f\n        }\n      }\n    }\n    if (scale)\n      for (let i = 0; i < ac.length; i++)\n        ac[i] = 0.5 + 0.5 / scale * ac[i]\n    return [dc, ac, scale]\n  }\n  let [l_dc, l_ac, l_scale] = encodeChannel(l, max(3, lx), max(3, ly))\n  let [p_dc, p_ac, p_scale] = encodeChannel(p, 3, 3)\n  let [q_dc, q_ac, q_scale] = encodeChannel(q, 3, 3)\n  let [a_dc, a_ac, a_scale] = hasAlpha ? encodeChannel(a, 5, 5) : []\n\n  // Write the constants\n  let isLandscape = w > h\n  let header24 = round(63 * l_dc) | (round(31.5 + 31.5 * p_dc) << 6) | (round(31.5 + 31.5 * q_dc) << 12) | (round(31 * l_scale) << 18) | (hasAlpha << 23)\n  let header16 = (isLandscape ? ly : lx) | (round(63 * p_scale) << 3) | (round(63 * q_scale) << 9) | (isLandscape << 15)\n  let hash = [header24 & 255, (header24 >> 8) & 255, header24 >> 16, header16 & 255, header16 >> 8]\n  let ac_start = hasAlpha ? 6 : 5\n  let ac_index = 0\n  if (hasAlpha) hash.push(round(15 * a_dc) | (round(15 * a_scale) << 4))\n\n  // Write the varying factors\n  for (let ac of hasAlpha ? [l_ac, p_ac, q_ac, a_ac] : [l_ac, p_ac, q_ac])\n    for (let f of ac)\n      hash[ac_start + (ac_index >> 1)] |= round(15 * f) << ((ac_index++ & 1) << 2)\n  return new Uint8Array(hash)\n}\n\n/**\n * Decodes a ThumbHash to an RGBA image. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The width, height, and pixels of the rendered placeholder image.\n */\nfunction thumbHashToRGBA(hash) {\n  let { PI, min, max, cos, round } = Math\n\n  // Read the constants\n  let header24 = hash[0] | (hash[1] << 8) | (hash[2] << 16)\n  let header16 = hash[3] | (hash[4] << 8)\n  let l_dc = (header24 & 63) / 63\n  let p_dc = ((header24 >> 6) & 63) / 31.5 - 1\n  let q_dc = ((header24 >> 12) & 63) / 31.5 - 1\n  let l_scale = ((header24 >> 18) & 31) / 31\n  let hasAlpha = header24 >> 23\n  let p_scale = ((header16 >> 3) & 63) / 63\n  let q_scale = ((header16 >> 9) & 63) / 63\n  let isLandscape = header16 >> 15\n  let lx = max(3, isLandscape ? hasAlpha ? 5 : 7 : header16 & 7)\n  let ly = max(3, isLandscape ? header16 & 7 : hasAlpha ? 5 : 7)\n  let a_dc = hasAlpha ? (hash[5] & 15) / 15 : 1\n  let a_scale = (hash[5] >> 4) / 15\n\n  // Read the varying factors (boost saturation by 1.25x to compensate for quantization)\n  let ac_start = hasAlpha ? 6 : 5\n  let ac_index = 0\n  let decodeChannel = (nx, ny, scale) => {\n    let ac = []\n    for (let cy = 0; cy < ny; cy++)\n      for (let cx = cy ? 0 : 1; cx * ny < nx * (ny - cy); cx++)\n        ac.push((((hash[ac_start + (ac_index >> 1)] >> ((ac_index++ & 1) << 2)) & 15) / 7.5 - 1) * scale)\n    return ac\n  }\n  let l_ac = decodeChannel(lx, ly, l_scale)\n  let p_ac = decodeChannel(3, 3, p_scale * 1.25)\n  let q_ac = decodeChannel(3, 3, q_scale * 1.25)\n  let a_ac = hasAlpha && decodeChannel(5, 5, a_scale)\n\n  // Decode using the DCT into RGB\n  let ratio = thumbHashToApproximateAspectRatio(hash)\n  let w = round(ratio > 1 ? 32 : 32 * ratio)\n  let h = round(ratio > 1 ? 32 / ratio : 32)\n  let rgba = new Uint8Array(w * h * 4), fx = [], fy = []\n  for (let y = 0, i = 0; y < h; y++) {\n    for (let x = 0; x < w; x++, i += 4) {\n      let l = l_dc, p = p_dc, q = q_dc, a = a_dc\n\n      // Precompute the coefficients\n      for (let cx = 0, n = max(lx, hasAlpha ? 5 : 3); cx < n; cx++)\n        fx[cx] = cos(PI / w * (x + 0.5) * cx)\n      for (let cy = 0, n = max(ly, hasAlpha ? 5 : 3); cy < n; cy++)\n        fy[cy] = cos(PI / h * (y + 0.5) * cy)\n\n      // Decode L\n      for (let cy = 0, j = 0; cy < ly; cy++)\n        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx * ly < lx * (ly - cy); cx++, j++)\n          l += l_ac[j] * fx[cx] * fy2\n\n      // Decode P and Q\n      for (let cy = 0, j = 0; cy < 3; cy++) {\n        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 3 - cy; cx++, j++) {\n          let f = fx[cx] * fy2\n          p += p_ac[j] * f\n          q += q_ac[j] * f\n        }\n      }\n\n      // Decode A\n      if (hasAlpha)\n        for (let cy = 0, j = 0; cy < 5; cy++)\n          for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 5 - cy; cx++, j++)\n            a += a_ac[j] * fx[cx] * fy2\n\n      // Convert to RGB\n      let b = l - 2 / 3 * p\n      let r = (3 * l - b + q) / 2\n      let g = r - q\n      rgba[i] = max(0, 255 * min(1, r))\n      rgba[i + 1] = max(0, 255 * min(1, g))\n      rgba[i + 2] = max(0, 255 * min(1, b))\n      rgba[i + 3] = max(0, 255 * min(1, a))\n    }\n  }\n  return { w, h, rgba }\n}\n\n/**\n * Extracts the average color from a ThumbHash. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The RGBA values for the average color. Each value ranges from 0 to 1.\n */\nfunction thumbHashToAverageRGBA(hash) {\n  let { min, max } = Math\n  let header = hash[0] | (hash[1] << 8) | (hash[2] << 16)\n  let l = (header & 63) / 63\n  let p = ((header >> 6) & 63) / 31.5 - 1\n  let q = ((header >> 12) & 63) / 31.5 - 1\n  let hasAlpha = header >> 23\n  let a = hasAlpha ? (hash[5] & 15) / 15 : 1\n  let b = l - 2 / 3 * p\n  let r = (3 * l - b + q) / 2\n  let g = r - q\n  return {\n    r: max(0, min(1, r)),\n    g: max(0, min(1, g)),\n    b: max(0, min(1, b)),\n    a\n  }\n}\n\n/**\n * Extracts the approximate aspect ratio of the original image.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The approximate aspect ratio (i.e. width / height).\n */\nfunction thumbHashToApproximateAspectRatio(hash) {\n  let header = hash[3]\n  let hasAlpha = hash[2] & 0x80\n  let isLandscape = hash[4] & 0x80\n  let lx = isLandscape ? hasAlpha ? 5 : 7 : header & 7\n  let ly = isLandscape ? header & 7 : hasAlpha ? 5 : 7\n  return lx / ly\n}\n\n/**\n * Encodes an RGBA image to a PNG data URL. RGB should not be premultiplied by\n * A. This is optimized for speed and simplicity and does not optimize for size\n * at all. This doesn't do any compression (all values are stored uncompressed).\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns A data URL containing a PNG for the input image.\n */\nfunction rgbaToDataURL(w, h, rgba) {\n  let row = w * 4 + 1\n  let idat = 6 + h * (5 + row)\n  let bytes = [\n    137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0,\n    w >> 8, w & 255, 0, 0, h >> 8, h & 255, 8, 6, 0, 0, 0, 0, 0, 0, 0,\n    idat >>> 24, (idat >> 16) & 255, (idat >> 8) & 255, idat & 255,\n    73, 68, 65, 84, 120, 1\n  ]\n  let table = [\n    0, 498536548, 997073096, 651767980, 1994146192, 1802195444, 1303535960,\n    1342533948, -306674912, -267414716, -690576408, -882789492, -1687895376,\n    -2032938284, -1609899400, -1111625188\n  ]\n  let a = 1, b = 0\n  for (let y = 0, i = 0, end = row - 1; y < h; y++, end += row - 1) {\n    bytes.push(y + 1 < h ? 0 : 1, row & 255, row >> 8, ~row & 255, (row >> 8) ^ 255, 0)\n    for (b = (b + a) % 65521; i < end; i++) {\n      let u = rgba[i] & 255\n      bytes.push(u)\n      a = (a + u) % 65521\n      b = (b + a) % 65521\n    }\n  }\n  bytes.push(\n    b >> 8, b & 255, a >> 8, a & 255, 0, 0, 0, 0,\n    0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130\n  )\n  for (let [start, end] of [[12, 29], [37, 41 + idat]]) {\n    let c = ~0\n    for (let i = start; i < end; i++) {\n      c ^= bytes[i]\n      c = (c >>> 4) ^ table[c & 15]\n      c = (c >>> 4) ^ table[c & 15]\n    }\n    c = ~c\n    bytes[end++] = c >>> 24\n    bytes[end++] = (c >> 16) & 255\n    bytes[end++] = (c >> 8) & 255\n    bytes[end++] = c & 255\n  }\n  return 'data:image/png;base64,' + btoa(String.fromCharCode(...bytes))\n}\n\n/**\n * Decodes a ThumbHash to a PNG data URL. This is a convenience function that\n * just calls \"thumbHashToRGBA\" followed by \"rgbaToDataURL\".\n *\n * @param hash The bytes of the ThumbHash.\n * @returns A data URL containing a PNG for the rendered ThumbHash.\n */\nfunction thumbHashToDataURL(hash) {\n  let image = thumbHashToRGBA(hash)\n  return rgbaToDataURL(image.w, image.h, image.rgba)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vdGh1bWJoYXNoQDAuMS4xL25vZGVfbW9kdWxlcy90aHVtYmhhc2gvdGh1bWJoYXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNkNBQTZDLEVBQUUsR0FBRyxHQUFHO0FBQ3JELFFBQVEsMkJBQTJCOztBQUVuQztBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLDZEQUE2RCxPQUFPO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSwyQkFBMkI7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUIsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMsb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEOztBQUVBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkMsb0RBQW9ELDBCQUEwQjtBQUM5RTs7QUFFQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDLHNEQUFzRCxhQUFhO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3Jmb2xpby8uL25vZGVfbW9kdWxlcy8ucG5wbS90aHVtYmhhc2hAMC4xLjEvbm9kZV9tb2R1bGVzL3RodW1iaGFzaC90aHVtYmhhc2guanM/MDBkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVuY29kZXMgYW4gUkdCQSBpbWFnZSB0byBhIFRodW1iSGFzaC4gUkdCIHNob3VsZCBub3QgYmUgcHJlbXVsdGlwbGllZCBieSBBLlxuICpcbiAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgaW1hZ2UuIE11c3QgYmUg4omkMTAwcHguXG4gKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCBpbWFnZS4gTXVzdCBiZSDiiaQxMDBweC5cbiAqIEBwYXJhbSByZ2JhIFRoZSBwaXhlbHMgaW4gdGhlIGlucHV0IGltYWdlLCByb3ctYnktcm93LiBNdXN0IGhhdmUgdypoKjQgZWxlbWVudHMuXG4gKiBAcmV0dXJucyBUaGUgVGh1bWJIYXNoIGFzIGEgVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJnYmFUb1RodW1iSGFzaCh3LCBoLCByZ2JhKSB7XG4gIC8vIEVuY29kaW5nIGFuIGltYWdlIGxhcmdlciB0aGFuIDEwMHgxMDAgaXMgc2xvdyB3aXRoIG5vIGJlbmVmaXRcbiAgaWYgKHcgPiAxMDAgfHwgaCA+IDEwMCkgdGhyb3cgbmV3IEVycm9yKGAke3d9eCR7aH0gZG9lc24ndCBmaXQgaW4gMTAweDEwMGApXG4gIGxldCB7IFBJLCByb3VuZCwgbWF4LCBjb3MsIGFicyB9ID0gTWF0aFxuXG4gIC8vIERldGVybWluZSB0aGUgYXZlcmFnZSBjb2xvclxuICBsZXQgYXZnX3IgPSAwLCBhdmdfZyA9IDAsIGF2Z19iID0gMCwgYXZnX2EgPSAwXG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHcgKiBoOyBpKyssIGogKz0gNCkge1xuICAgIGxldCBhbHBoYSA9IHJnYmFbaiArIDNdIC8gMjU1XG4gICAgYXZnX3IgKz0gYWxwaGEgLyAyNTUgKiByZ2JhW2pdXG4gICAgYXZnX2cgKz0gYWxwaGEgLyAyNTUgKiByZ2JhW2ogKyAxXVxuICAgIGF2Z19iICs9IGFscGhhIC8gMjU1ICogcmdiYVtqICsgMl1cbiAgICBhdmdfYSArPSBhbHBoYVxuICB9XG4gIGlmIChhdmdfYSkge1xuICAgIGF2Z19yIC89IGF2Z19hXG4gICAgYXZnX2cgLz0gYXZnX2FcbiAgICBhdmdfYiAvPSBhdmdfYVxuICB9XG5cbiAgbGV0IGhhc0FscGhhID0gYXZnX2EgPCB3ICogaFxuICBsZXQgbF9saW1pdCA9IGhhc0FscGhhID8gNSA6IDcgLy8gVXNlIGZld2VyIGx1bWluYW5jZSBiaXRzIGlmIHRoZXJlJ3MgYWxwaGFcbiAgbGV0IGx4ID0gbWF4KDEsIHJvdW5kKGxfbGltaXQgKiB3IC8gbWF4KHcsIGgpKSlcbiAgbGV0IGx5ID0gbWF4KDEsIHJvdW5kKGxfbGltaXQgKiBoIC8gbWF4KHcsIGgpKSlcbiAgbGV0IGwgPSBbXSAvLyBsdW1pbmFuY2VcbiAgbGV0IHAgPSBbXSAvLyB5ZWxsb3cgLSBibHVlXG4gIGxldCBxID0gW10gLy8gcmVkIC0gZ3JlZW5cbiAgbGV0IGEgPSBbXSAvLyBhbHBoYVxuXG4gIC8vIENvbnZlcnQgdGhlIGltYWdlIGZyb20gUkdCQSB0byBMUFFBIChjb21wb3NpdGUgYXRvcCB0aGUgYXZlcmFnZSBjb2xvcilcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdyAqIGg7IGkrKywgaiArPSA0KSB7XG4gICAgbGV0IGFscGhhID0gcmdiYVtqICsgM10gLyAyNTVcbiAgICBsZXQgciA9IGF2Z19yICogKDEgLSBhbHBoYSkgKyBhbHBoYSAvIDI1NSAqIHJnYmFbal1cbiAgICBsZXQgZyA9IGF2Z19nICogKDEgLSBhbHBoYSkgKyBhbHBoYSAvIDI1NSAqIHJnYmFbaiArIDFdXG4gICAgbGV0IGIgPSBhdmdfYiAqICgxIC0gYWxwaGEpICsgYWxwaGEgLyAyNTUgKiByZ2JhW2ogKyAyXVxuICAgIGxbaV0gPSAociArIGcgKyBiKSAvIDNcbiAgICBwW2ldID0gKHIgKyBnKSAvIDIgLSBiXG4gICAgcVtpXSA9IHIgLSBnXG4gICAgYVtpXSA9IGFscGhhXG4gIH1cblxuICAvLyBFbmNvZGUgdXNpbmcgdGhlIERDVCBpbnRvIERDIChjb25zdGFudCkgYW5kIG5vcm1hbGl6ZWQgQUMgKHZhcnlpbmcpIHRlcm1zXG4gIGxldCBlbmNvZGVDaGFubmVsID0gKGNoYW5uZWwsIG54LCBueSkgPT4ge1xuICAgIGxldCBkYyA9IDAsIGFjID0gW10sIHNjYWxlID0gMCwgZnggPSBbXVxuICAgIGZvciAobGV0IGN5ID0gMDsgY3kgPCBueTsgY3krKykge1xuICAgICAgZm9yIChsZXQgY3ggPSAwOyBjeCAqIG55IDwgbnggKiAobnkgLSBjeSk7IGN4KyspIHtcbiAgICAgICAgbGV0IGYgPSAwXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdzsgeCsrKVxuICAgICAgICAgIGZ4W3hdID0gY29zKFBJIC8gdyAqIGN4ICogKHggKyAwLjUpKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGg7IHkrKylcbiAgICAgICAgICBmb3IgKGxldCB4ID0gMCwgZnkgPSBjb3MoUEkgLyBoICogY3kgKiAoeSArIDAuNSkpOyB4IDwgdzsgeCsrKVxuICAgICAgICAgICAgZiArPSBjaGFubmVsW3ggKyB5ICogd10gKiBmeFt4XSAqIGZ5XG4gICAgICAgIGYgLz0gdyAqIGhcbiAgICAgICAgaWYgKGN4IHx8IGN5KSB7XG4gICAgICAgICAgYWMucHVzaChmKVxuICAgICAgICAgIHNjYWxlID0gbWF4KHNjYWxlLCBhYnMoZikpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGMgPSBmXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjYWxlKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhYy5sZW5ndGg7IGkrKylcbiAgICAgICAgYWNbaV0gPSAwLjUgKyAwLjUgLyBzY2FsZSAqIGFjW2ldXG4gICAgcmV0dXJuIFtkYywgYWMsIHNjYWxlXVxuICB9XG4gIGxldCBbbF9kYywgbF9hYywgbF9zY2FsZV0gPSBlbmNvZGVDaGFubmVsKGwsIG1heCgzLCBseCksIG1heCgzLCBseSkpXG4gIGxldCBbcF9kYywgcF9hYywgcF9zY2FsZV0gPSBlbmNvZGVDaGFubmVsKHAsIDMsIDMpXG4gIGxldCBbcV9kYywgcV9hYywgcV9zY2FsZV0gPSBlbmNvZGVDaGFubmVsKHEsIDMsIDMpXG4gIGxldCBbYV9kYywgYV9hYywgYV9zY2FsZV0gPSBoYXNBbHBoYSA/IGVuY29kZUNoYW5uZWwoYSwgNSwgNSkgOiBbXVxuXG4gIC8vIFdyaXRlIHRoZSBjb25zdGFudHNcbiAgbGV0IGlzTGFuZHNjYXBlID0gdyA+IGhcbiAgbGV0IGhlYWRlcjI0ID0gcm91bmQoNjMgKiBsX2RjKSB8IChyb3VuZCgzMS41ICsgMzEuNSAqIHBfZGMpIDw8IDYpIHwgKHJvdW5kKDMxLjUgKyAzMS41ICogcV9kYykgPDwgMTIpIHwgKHJvdW5kKDMxICogbF9zY2FsZSkgPDwgMTgpIHwgKGhhc0FscGhhIDw8IDIzKVxuICBsZXQgaGVhZGVyMTYgPSAoaXNMYW5kc2NhcGUgPyBseSA6IGx4KSB8IChyb3VuZCg2MyAqIHBfc2NhbGUpIDw8IDMpIHwgKHJvdW5kKDYzICogcV9zY2FsZSkgPDwgOSkgfCAoaXNMYW5kc2NhcGUgPDwgMTUpXG4gIGxldCBoYXNoID0gW2hlYWRlcjI0ICYgMjU1LCAoaGVhZGVyMjQgPj4gOCkgJiAyNTUsIGhlYWRlcjI0ID4+IDE2LCBoZWFkZXIxNiAmIDI1NSwgaGVhZGVyMTYgPj4gOF1cbiAgbGV0IGFjX3N0YXJ0ID0gaGFzQWxwaGEgPyA2IDogNVxuICBsZXQgYWNfaW5kZXggPSAwXG4gIGlmIChoYXNBbHBoYSkgaGFzaC5wdXNoKHJvdW5kKDE1ICogYV9kYykgfCAocm91bmQoMTUgKiBhX3NjYWxlKSA8PCA0KSlcblxuICAvLyBXcml0ZSB0aGUgdmFyeWluZyBmYWN0b3JzXG4gIGZvciAobGV0IGFjIG9mIGhhc0FscGhhID8gW2xfYWMsIHBfYWMsIHFfYWMsIGFfYWNdIDogW2xfYWMsIHBfYWMsIHFfYWNdKVxuICAgIGZvciAobGV0IGYgb2YgYWMpXG4gICAgICBoYXNoW2FjX3N0YXJ0ICsgKGFjX2luZGV4ID4+IDEpXSB8PSByb3VuZCgxNSAqIGYpIDw8ICgoYWNfaW5kZXgrKyAmIDEpIDw8IDIpXG4gIHJldHVybiBuZXcgVWludDhBcnJheShoYXNoKVxufVxuXG4vKipcbiAqIERlY29kZXMgYSBUaHVtYkhhc2ggdG8gYW4gUkdCQSBpbWFnZS4gUkdCIGlzIG5vdCBiZSBwcmVtdWx0aXBsaWVkIGJ5IEEuXG4gKlxuICogQHBhcmFtIGhhc2ggVGhlIGJ5dGVzIG9mIHRoZSBUaHVtYkhhc2guXG4gKiBAcmV0dXJucyBUaGUgd2lkdGgsIGhlaWdodCwgYW5kIHBpeGVscyBvZiB0aGUgcmVuZGVyZWQgcGxhY2Vob2xkZXIgaW1hZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHVtYkhhc2hUb1JHQkEoaGFzaCkge1xuICBsZXQgeyBQSSwgbWluLCBtYXgsIGNvcywgcm91bmQgfSA9IE1hdGhcblxuICAvLyBSZWFkIHRoZSBjb25zdGFudHNcbiAgbGV0IGhlYWRlcjI0ID0gaGFzaFswXSB8IChoYXNoWzFdIDw8IDgpIHwgKGhhc2hbMl0gPDwgMTYpXG4gIGxldCBoZWFkZXIxNiA9IGhhc2hbM10gfCAoaGFzaFs0XSA8PCA4KVxuICBsZXQgbF9kYyA9IChoZWFkZXIyNCAmIDYzKSAvIDYzXG4gIGxldCBwX2RjID0gKChoZWFkZXIyNCA+PiA2KSAmIDYzKSAvIDMxLjUgLSAxXG4gIGxldCBxX2RjID0gKChoZWFkZXIyNCA+PiAxMikgJiA2MykgLyAzMS41IC0gMVxuICBsZXQgbF9zY2FsZSA9ICgoaGVhZGVyMjQgPj4gMTgpICYgMzEpIC8gMzFcbiAgbGV0IGhhc0FscGhhID0gaGVhZGVyMjQgPj4gMjNcbiAgbGV0IHBfc2NhbGUgPSAoKGhlYWRlcjE2ID4+IDMpICYgNjMpIC8gNjNcbiAgbGV0IHFfc2NhbGUgPSAoKGhlYWRlcjE2ID4+IDkpICYgNjMpIC8gNjNcbiAgbGV0IGlzTGFuZHNjYXBlID0gaGVhZGVyMTYgPj4gMTVcbiAgbGV0IGx4ID0gbWF4KDMsIGlzTGFuZHNjYXBlID8gaGFzQWxwaGEgPyA1IDogNyA6IGhlYWRlcjE2ICYgNylcbiAgbGV0IGx5ID0gbWF4KDMsIGlzTGFuZHNjYXBlID8gaGVhZGVyMTYgJiA3IDogaGFzQWxwaGEgPyA1IDogNylcbiAgbGV0IGFfZGMgPSBoYXNBbHBoYSA/IChoYXNoWzVdICYgMTUpIC8gMTUgOiAxXG4gIGxldCBhX3NjYWxlID0gKGhhc2hbNV0gPj4gNCkgLyAxNVxuXG4gIC8vIFJlYWQgdGhlIHZhcnlpbmcgZmFjdG9ycyAoYm9vc3Qgc2F0dXJhdGlvbiBieSAxLjI1eCB0byBjb21wZW5zYXRlIGZvciBxdWFudGl6YXRpb24pXG4gIGxldCBhY19zdGFydCA9IGhhc0FscGhhID8gNiA6IDVcbiAgbGV0IGFjX2luZGV4ID0gMFxuICBsZXQgZGVjb2RlQ2hhbm5lbCA9IChueCwgbnksIHNjYWxlKSA9PiB7XG4gICAgbGV0IGFjID0gW11cbiAgICBmb3IgKGxldCBjeSA9IDA7IGN5IDwgbnk7IGN5KyspXG4gICAgICBmb3IgKGxldCBjeCA9IGN5ID8gMCA6IDE7IGN4ICogbnkgPCBueCAqIChueSAtIGN5KTsgY3grKylcbiAgICAgICAgYWMucHVzaCgoKChoYXNoW2FjX3N0YXJ0ICsgKGFjX2luZGV4ID4+IDEpXSA+PiAoKGFjX2luZGV4KysgJiAxKSA8PCAyKSkgJiAxNSkgLyA3LjUgLSAxKSAqIHNjYWxlKVxuICAgIHJldHVybiBhY1xuICB9XG4gIGxldCBsX2FjID0gZGVjb2RlQ2hhbm5lbChseCwgbHksIGxfc2NhbGUpXG4gIGxldCBwX2FjID0gZGVjb2RlQ2hhbm5lbCgzLCAzLCBwX3NjYWxlICogMS4yNSlcbiAgbGV0IHFfYWMgPSBkZWNvZGVDaGFubmVsKDMsIDMsIHFfc2NhbGUgKiAxLjI1KVxuICBsZXQgYV9hYyA9IGhhc0FscGhhICYmIGRlY29kZUNoYW5uZWwoNSwgNSwgYV9zY2FsZSlcblxuICAvLyBEZWNvZGUgdXNpbmcgdGhlIERDVCBpbnRvIFJHQlxuICBsZXQgcmF0aW8gPSB0aHVtYkhhc2hUb0FwcHJveGltYXRlQXNwZWN0UmF0aW8oaGFzaClcbiAgbGV0IHcgPSByb3VuZChyYXRpbyA+IDEgPyAzMiA6IDMyICogcmF0aW8pXG4gIGxldCBoID0gcm91bmQocmF0aW8gPiAxID8gMzIgLyByYXRpbyA6IDMyKVxuICBsZXQgcmdiYSA9IG5ldyBVaW50OEFycmF5KHcgKiBoICogNCksIGZ4ID0gW10sIGZ5ID0gW11cbiAgZm9yIChsZXQgeSA9IDAsIGkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB3OyB4KyssIGkgKz0gNCkge1xuICAgICAgbGV0IGwgPSBsX2RjLCBwID0gcF9kYywgcSA9IHFfZGMsIGEgPSBhX2RjXG5cbiAgICAgIC8vIFByZWNvbXB1dGUgdGhlIGNvZWZmaWNpZW50c1xuICAgICAgZm9yIChsZXQgY3ggPSAwLCBuID0gbWF4KGx4LCBoYXNBbHBoYSA/IDUgOiAzKTsgY3ggPCBuOyBjeCsrKVxuICAgICAgICBmeFtjeF0gPSBjb3MoUEkgLyB3ICogKHggKyAwLjUpICogY3gpXG4gICAgICBmb3IgKGxldCBjeSA9IDAsIG4gPSBtYXgobHksIGhhc0FscGhhID8gNSA6IDMpOyBjeSA8IG47IGN5KyspXG4gICAgICAgIGZ5W2N5XSA9IGNvcyhQSSAvIGggKiAoeSArIDAuNSkgKiBjeSlcblxuICAgICAgLy8gRGVjb2RlIExcbiAgICAgIGZvciAobGV0IGN5ID0gMCwgaiA9IDA7IGN5IDwgbHk7IGN5KyspXG4gICAgICAgIGZvciAobGV0IGN4ID0gY3kgPyAwIDogMSwgZnkyID0gZnlbY3ldICogMjsgY3ggKiBseSA8IGx4ICogKGx5IC0gY3kpOyBjeCsrLCBqKyspXG4gICAgICAgICAgbCArPSBsX2FjW2pdICogZnhbY3hdICogZnkyXG5cbiAgICAgIC8vIERlY29kZSBQIGFuZCBRXG4gICAgICBmb3IgKGxldCBjeSA9IDAsIGogPSAwOyBjeSA8IDM7IGN5KyspIHtcbiAgICAgICAgZm9yIChsZXQgY3ggPSBjeSA/IDAgOiAxLCBmeTIgPSBmeVtjeV0gKiAyOyBjeCA8IDMgLSBjeTsgY3grKywgaisrKSB7XG4gICAgICAgICAgbGV0IGYgPSBmeFtjeF0gKiBmeTJcbiAgICAgICAgICBwICs9IHBfYWNbal0gKiBmXG4gICAgICAgICAgcSArPSBxX2FjW2pdICogZlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERlY29kZSBBXG4gICAgICBpZiAoaGFzQWxwaGEpXG4gICAgICAgIGZvciAobGV0IGN5ID0gMCwgaiA9IDA7IGN5IDwgNTsgY3krKylcbiAgICAgICAgICBmb3IgKGxldCBjeCA9IGN5ID8gMCA6IDEsIGZ5MiA9IGZ5W2N5XSAqIDI7IGN4IDwgNSAtIGN5OyBjeCsrLCBqKyspXG4gICAgICAgICAgICBhICs9IGFfYWNbal0gKiBmeFtjeF0gKiBmeTJcblxuICAgICAgLy8gQ29udmVydCB0byBSR0JcbiAgICAgIGxldCBiID0gbCAtIDIgLyAzICogcFxuICAgICAgbGV0IHIgPSAoMyAqIGwgLSBiICsgcSkgLyAyXG4gICAgICBsZXQgZyA9IHIgLSBxXG4gICAgICByZ2JhW2ldID0gbWF4KDAsIDI1NSAqIG1pbigxLCByKSlcbiAgICAgIHJnYmFbaSArIDFdID0gbWF4KDAsIDI1NSAqIG1pbigxLCBnKSlcbiAgICAgIHJnYmFbaSArIDJdID0gbWF4KDAsIDI1NSAqIG1pbigxLCBiKSlcbiAgICAgIHJnYmFbaSArIDNdID0gbWF4KDAsIDI1NSAqIG1pbigxLCBhKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdywgaCwgcmdiYSB9XG59XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGF2ZXJhZ2UgY29sb3IgZnJvbSBhIFRodW1iSGFzaC4gUkdCIGlzIG5vdCBiZSBwcmVtdWx0aXBsaWVkIGJ5IEEuXG4gKlxuICogQHBhcmFtIGhhc2ggVGhlIGJ5dGVzIG9mIHRoZSBUaHVtYkhhc2guXG4gKiBAcmV0dXJucyBUaGUgUkdCQSB2YWx1ZXMgZm9yIHRoZSBhdmVyYWdlIGNvbG9yLiBFYWNoIHZhbHVlIHJhbmdlcyBmcm9tIDAgdG8gMS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRodW1iSGFzaFRvQXZlcmFnZVJHQkEoaGFzaCkge1xuICBsZXQgeyBtaW4sIG1heCB9ID0gTWF0aFxuICBsZXQgaGVhZGVyID0gaGFzaFswXSB8IChoYXNoWzFdIDw8IDgpIHwgKGhhc2hbMl0gPDwgMTYpXG4gIGxldCBsID0gKGhlYWRlciAmIDYzKSAvIDYzXG4gIGxldCBwID0gKChoZWFkZXIgPj4gNikgJiA2MykgLyAzMS41IC0gMVxuICBsZXQgcSA9ICgoaGVhZGVyID4+IDEyKSAmIDYzKSAvIDMxLjUgLSAxXG4gIGxldCBoYXNBbHBoYSA9IGhlYWRlciA+PiAyM1xuICBsZXQgYSA9IGhhc0FscGhhID8gKGhhc2hbNV0gJiAxNSkgLyAxNSA6IDFcbiAgbGV0IGIgPSBsIC0gMiAvIDMgKiBwXG4gIGxldCByID0gKDMgKiBsIC0gYiArIHEpIC8gMlxuICBsZXQgZyA9IHIgLSBxXG4gIHJldHVybiB7XG4gICAgcjogbWF4KDAsIG1pbigxLCByKSksXG4gICAgZzogbWF4KDAsIG1pbigxLCBnKSksXG4gICAgYjogbWF4KDAsIG1pbigxLCBiKSksXG4gICAgYVxuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGFwcHJveGltYXRlIGFzcGVjdCByYXRpbyBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UuXG4gKlxuICogQHBhcmFtIGhhc2ggVGhlIGJ5dGVzIG9mIHRoZSBUaHVtYkhhc2guXG4gKiBAcmV0dXJucyBUaGUgYXBwcm94aW1hdGUgYXNwZWN0IHJhdGlvIChpLmUuIHdpZHRoIC8gaGVpZ2h0KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRodW1iSGFzaFRvQXBwcm94aW1hdGVBc3BlY3RSYXRpbyhoYXNoKSB7XG4gIGxldCBoZWFkZXIgPSBoYXNoWzNdXG4gIGxldCBoYXNBbHBoYSA9IGhhc2hbMl0gJiAweDgwXG4gIGxldCBpc0xhbmRzY2FwZSA9IGhhc2hbNF0gJiAweDgwXG4gIGxldCBseCA9IGlzTGFuZHNjYXBlID8gaGFzQWxwaGEgPyA1IDogNyA6IGhlYWRlciAmIDdcbiAgbGV0IGx5ID0gaXNMYW5kc2NhcGUgPyBoZWFkZXIgJiA3IDogaGFzQWxwaGEgPyA1IDogN1xuICByZXR1cm4gbHggLyBseVxufVxuXG4vKipcbiAqIEVuY29kZXMgYW4gUkdCQSBpbWFnZSB0byBhIFBORyBkYXRhIFVSTC4gUkdCIHNob3VsZCBub3QgYmUgcHJlbXVsdGlwbGllZCBieVxuICogQS4gVGhpcyBpcyBvcHRpbWl6ZWQgZm9yIHNwZWVkIGFuZCBzaW1wbGljaXR5IGFuZCBkb2VzIG5vdCBvcHRpbWl6ZSBmb3Igc2l6ZVxuICogYXQgYWxsLiBUaGlzIGRvZXNuJ3QgZG8gYW55IGNvbXByZXNzaW9uIChhbGwgdmFsdWVzIGFyZSBzdG9yZWQgdW5jb21wcmVzc2VkKS5cbiAqXG4gKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIGlucHV0IGltYWdlLiBNdXN0IGJlIOKJpDEwMHB4LlxuICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgaW1hZ2UuIE11c3QgYmUg4omkMTAwcHguXG4gKiBAcGFyYW0gcmdiYSBUaGUgcGl4ZWxzIGluIHRoZSBpbnB1dCBpbWFnZSwgcm93LWJ5LXJvdy4gTXVzdCBoYXZlIHcqaCo0IGVsZW1lbnRzLlxuICogQHJldHVybnMgQSBkYXRhIFVSTCBjb250YWluaW5nIGEgUE5HIGZvciB0aGUgaW5wdXQgaW1hZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZ2JhVG9EYXRhVVJMKHcsIGgsIHJnYmEpIHtcbiAgbGV0IHJvdyA9IHcgKiA0ICsgMVxuICBsZXQgaWRhdCA9IDYgKyBoICogKDUgKyByb3cpXG4gIGxldCBieXRlcyA9IFtcbiAgICAxMzcsIDgwLCA3OCwgNzEsIDEzLCAxMCwgMjYsIDEwLCAwLCAwLCAwLCAxMywgNzMsIDcyLCA2OCwgODIsIDAsIDAsXG4gICAgdyA+PiA4LCB3ICYgMjU1LCAwLCAwLCBoID4+IDgsIGggJiAyNTUsIDgsIDYsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgaWRhdCA+Pj4gMjQsIChpZGF0ID4+IDE2KSAmIDI1NSwgKGlkYXQgPj4gOCkgJiAyNTUsIGlkYXQgJiAyNTUsXG4gICAgNzMsIDY4LCA2NSwgODQsIDEyMCwgMVxuICBdXG4gIGxldCB0YWJsZSA9IFtcbiAgICAwLCA0OTg1MzY1NDgsIDk5NzA3MzA5NiwgNjUxNzY3OTgwLCAxOTk0MTQ2MTkyLCAxODAyMTk1NDQ0LCAxMzAzNTM1OTYwLFxuICAgIDEzNDI1MzM5NDgsIC0zMDY2NzQ5MTIsIC0yNjc0MTQ3MTYsIC02OTA1NzY0MDgsIC04ODI3ODk0OTIsIC0xNjg3ODk1Mzc2LFxuICAgIC0yMDMyOTM4Mjg0LCAtMTYwOTg5OTQwMCwgLTExMTE2MjUxODhcbiAgXVxuICBsZXQgYSA9IDEsIGIgPSAwXG4gIGZvciAobGV0IHkgPSAwLCBpID0gMCwgZW5kID0gcm93IC0gMTsgeSA8IGg7IHkrKywgZW5kICs9IHJvdyAtIDEpIHtcbiAgICBieXRlcy5wdXNoKHkgKyAxIDwgaCA/IDAgOiAxLCByb3cgJiAyNTUsIHJvdyA+PiA4LCB+cm93ICYgMjU1LCAocm93ID4+IDgpIF4gMjU1LCAwKVxuICAgIGZvciAoYiA9IChiICsgYSkgJSA2NTUyMTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBsZXQgdSA9IHJnYmFbaV0gJiAyNTVcbiAgICAgIGJ5dGVzLnB1c2godSlcbiAgICAgIGEgPSAoYSArIHUpICUgNjU1MjFcbiAgICAgIGIgPSAoYiArIGEpICUgNjU1MjFcbiAgICB9XG4gIH1cbiAgYnl0ZXMucHVzaChcbiAgICBiID4+IDgsIGIgJiAyNTUsIGEgPj4gOCwgYSAmIDI1NSwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCA3MywgNjksIDc4LCA2OCwgMTc0LCA2NiwgOTYsIDEzMFxuICApXG4gIGZvciAobGV0IFtzdGFydCwgZW5kXSBvZiBbWzEyLCAyOV0sIFszNywgNDEgKyBpZGF0XV0pIHtcbiAgICBsZXQgYyA9IH4wXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIGMgXj0gYnl0ZXNbaV1cbiAgICAgIGMgPSAoYyA+Pj4gNCkgXiB0YWJsZVtjICYgMTVdXG4gICAgICBjID0gKGMgPj4+IDQpIF4gdGFibGVbYyAmIDE1XVxuICAgIH1cbiAgICBjID0gfmNcbiAgICBieXRlc1tlbmQrK10gPSBjID4+PiAyNFxuICAgIGJ5dGVzW2VuZCsrXSA9IChjID4+IDE2KSAmIDI1NVxuICAgIGJ5dGVzW2VuZCsrXSA9IChjID4+IDgpICYgMjU1XG4gICAgYnl0ZXNbZW5kKytdID0gYyAmIDI1NVxuICB9XG4gIHJldHVybiAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LCcgKyBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYnl0ZXMpKVxufVxuXG4vKipcbiAqIERlY29kZXMgYSBUaHVtYkhhc2ggdG8gYSBQTkcgZGF0YSBVUkwuIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0aGF0XG4gKiBqdXN0IGNhbGxzIFwidGh1bWJIYXNoVG9SR0JBXCIgZm9sbG93ZWQgYnkgXCJyZ2JhVG9EYXRhVVJMXCIuXG4gKlxuICogQHBhcmFtIGhhc2ggVGhlIGJ5dGVzIG9mIHRoZSBUaHVtYkhhc2guXG4gKiBAcmV0dXJucyBBIGRhdGEgVVJMIGNvbnRhaW5pbmcgYSBQTkcgZm9yIHRoZSByZW5kZXJlZCBUaHVtYkhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHVtYkhhc2hUb0RhdGFVUkwoaGFzaCkge1xuICBsZXQgaW1hZ2UgPSB0aHVtYkhhc2hUb1JHQkEoaGFzaClcbiAgcmV0dXJuIHJnYmFUb0RhdGFVUkwoaW1hZ2UudywgaW1hZ2UuaCwgaW1hZ2UucmdiYSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/thumbhash@0.1.1/node_modules/thumbhash/thumbhash.js\n");

/***/ })

};
;